<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Agent Visualizer - AI Agent å·¥ä½œæµç¨‹å¯è§†åŒ–</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --bg-primary: #0f172a;
            --bg-secondary: #1e293b;
            --bg-tertiary: #334155;
            --border-color: #475569;
            --text-primary: #f1f5f9;
            --text-secondary: #94a3b8;
            --accent: #8b5cf6;
            --accent-hover: #7c3aed;
            --success: #22c55e;
            --warning: #eab308;
            --error: #ef4444;
            --waiting: #6b7280;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            height: 100vh;
            overflow: hidden;
        }

        /* é¡¶éƒ¨æ§åˆ¶æ  */
        .control-bar {
            height: 60px;
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border-color);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 20px;
        }

        .control-bar h1 {
            font-size: 18px;
            font-weight: 600;
            background: linear-gradient(135deg, #8b5cf6, #ec4899);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .controls {
            display: flex;
            gap: 10px;
        }

        .btn {
            padding: 8px 16px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .btn-primary {
            background: var(--accent);
            color: white;
        }

        .btn-primary:hover {
            background: var(--accent-hover);
        }

        .btn-secondary {
            background: var(--bg-tertiary);
            color: var(--text-primary);
        }

        .btn-secondary:hover {
            background: var(--border-color);
        }

        .btn-success {
            background: var(--success);
            color: white;
        }

        .btn-success:hover {
            background: #16a34a;
        }

        .btn-danger {
            background: var(--error);
            color: white;
        }

        .btn-danger:hover {
            background: #dc2626;
        }

        /* ä¸»å¸ƒå±€ */
        .main-container {
            display: flex;
            height: calc(100vh - 60px);
        }

        /* å·¦ä¾§ Agent åˆ—è¡¨ */
        .agent-list {
            width: 260px;
            background: var(--bg-secondary);
            border-right: 1px solid var(--border-color);
            padding: 16px;
            overflow-y: auto;
        }

        .agent-list h2 {
            font-size: 14px;
            color: var(--text-secondary);
            margin-bottom: 12px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .agent-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.2s;
            margin-bottom: 8px;
            border: 1px solid transparent;
        }

        .agent-item:hover {
            background: var(--bg-tertiary);
        }

        /* Agent èŠ‚ç‚¹è¿æ¥ç‚¹ */
        .agent-node .connect-point {
            transition: opacity 0.2s;
        }

        .agent-node:hover .connect-point {
            opacity: 1 !important;
        }

        .agent-item.active {
            background: var(--bg-tertiary);
            border-color: var(--accent);
        }

        .agent-avatar {
            width: 40px;
            height: 40px;
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            font-weight: bold;
        }

        .agent-info {
            flex: 1;
        }

        .agent-name {
            font-weight: 500;
            font-size: 14px;
        }

        .agent-role {
            font-size: 12px;
            color: var(--text-secondary);
        }

        .agent-status {
            width: 10px;
            height: 10px;
            border-radius: 50%;
        }

        .status-running { background: var(--success); box-shadow: 0 0 8px var(--success); }
        .status-waiting { background: var(--warning); }
        .status-completed { background: var(--waiting); }
        .status-failed { background: var(--error); }

        /* ä¸­é—´å¯è§†åŒ–åŒºåŸŸ */
        .visualization {
            flex: 1;
            position: relative;
            background: var(--bg-primary);
            overflow: hidden;
        }

        .visualization canvas {
            width: 100%;
            height: 100%;
        }

        #threeCanvas {
            position: absolute;
            top: 0;
            left: 0;
        }

        /* 3D è§†å›¾æ§åˆ¶æç¤º */
        .view-hint {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: var(--bg-secondary);
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 13px;
            color: var(--text-secondary);
            opacity: 0;
            transition: opacity 0.3s;
            pointer-events: none;
        }

        .view-hint.show {
            opacity: 1;
        }

        .empty-state {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            color: var(--text-secondary);
        }

        .empty-state svg {
            width: 80px;
            height: 80px;
            margin-bottom: 16px;
            opacity: 0.5;
        }

        /* å³ä¾§è¯¦æƒ…é¢æ¿ */
        .details-panel {
            width: 320px;
            background: var(--bg-secondary);
            border-left: 1px solid var(--border-color);
            padding: 16px;
            overflow-y: auto;
        }

        .details-panel.collapsed {
            width: 0;
            padding: 0;
            overflow: hidden;
        }

        .panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 16px;
        }

        .panel-header h2 {
            font-size: 16px;
            font-weight: 600;
        }

        .close-btn {
            background: none;
            border: none;
            color: var(--text-secondary);
            cursor: pointer;
            font-size: 20px;
        }

        .detail-section {
            margin-bottom: 20px;
        }

        .detail-section h3 {
            font-size: 12px;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 8px;
        }

        .detail-item {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid var(--border-color);
        }

        .detail-label {
            color: var(--text-secondary);
            font-size: 13px;
        }

        .detail-value {
            font-size: 13px;
            font-weight: 500;
        }

        .message-list {
            max-height: 300px;
            overflow-y: auto;
        }

        .message-item {
            padding: 12px;
            background: var(--bg-tertiary);
            border-radius: 8px;
            margin-bottom: 8px;
        }

        .message-header {
            display: flex;
            justify-content: space-between;
            margin-bottom: 6px;
            font-size: 12px;
        }

        .message-from {
            color: var(--accent);
            font-weight: 500;
        }

        .message-to {
            color: var(--success);
        }

        .message-time {
            color: var(--text-secondary);
        }

        .message-content {
            font-size: 13px;
            line-height: 1.5;
            color: var(--text-secondary);
        }

        /* æ—¶é—´çº¿ */
        .timeline {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: var(--bg-secondary);
            padding: 12px 20px;
            border-radius: 30px;
            display: flex;
            align-items: center;
            gap: 16px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
        }

        .timeline-btn {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            border: none;
            background: var(--bg-tertiary);
            color: var(--text-primary);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }

        .timeline-btn:hover {
            background: var(--accent);
        }

        .timeline-progress {
            width: 200px;
            height: 6px;
            background: var(--bg-tertiary);
            border-radius: 3px;
            cursor: pointer;
        }

        .timeline-progress-bar {
            height: 100%;
            background: linear-gradient(90deg, var(--accent), #ec4899);
            border-radius: 3px;
            width: 0%;
            transition: width 0.3s;
        }

        .timeline-time {
            font-size: 13px;
            color: var(--text-secondary);
            min-width: 80px;
        }

        /* æ·»åŠ  Agent æŒ‰é’® */
        .add-agent-btn {
            width: 100%;
            padding: 12px;
            border: 2px dashed var(--border-color);
            border-radius: 10px;
            background: transparent;
            color: var(--text-secondary);
            cursor: pointer;
            transition: all 0.2s;
            margin-top: 12px;
        }

        .add-agent-btn:hover {
            border-color: var(--accent);
            color: var(--accent);
        }

        /* æ‹–æ‹½è§’è‰²å¡ç‰Œ */
        .role-cards {
            margin-top: 16px;
            padding-top: 16px;
            border-top: 1px solid var(--border-color);
        }

        .role-cards-title {
            font-size: 12px;
            color: var(--text-secondary);
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .role-card {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px;
            border-radius: 8px;
            cursor: grab;
            transition: all 0.2s;
            margin-bottom: 8px;
            background: var(--bg-tertiary);
            border: 1px solid transparent;
        }

        .role-card:hover {
            border-color: var(--accent);
            transform: translateX(4px);
        }

        .role-card.dragging {
            opacity: 0.5;
            cursor: grabbing;
        }

        .role-card-icon {
            width: 32px;
            height: 32px;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
        }

        .role-card-info {
            flex: 1;
        }

        .role-card-name {
            font-size: 13px;
            font-weight: 500;
        }

        .role-card-role {
            font-size: 11px;
            color: var(--text-secondary);
        }

        /* æ‹–æ‹½æ”¾ç½®åŒºåŸŸ */
        .visualization.drag-over {
            background: rgba(139, 92, 246, 0.1);
        }

        .visualization.drag-over::after {
            content: 'æ‹–æ”¾åˆ°è¿™é‡Œåˆ›å»º Agent';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 18px;
            color: var(--accent);
            padding: 20px 40px;
            border: 2px dashed var(--accent);
            border-radius: 12px;
            background: var(--bg-secondary);
            pointer-events: none;
            z-index: 100;
        }

        .drop-indicator {
            position: absolute;
            width: 80px;
            height: 80px;
            border: 3px dashed var(--accent);
            border-radius: 12px;
            background: rgba(139, 92, 246, 0.2);
            pointer-events: none;
            display: none;
            justify-content: center;
            align-items: center;
            color: var(--accent);
            font-size: 24px;
        }

        .drop-indicator.show {
            display: flex;
        }

        /* æ‹–æ‹½è¿æ¥çº¿ */
        .connection-line {
            stroke: var(--accent);
            stroke-width: 2;
            stroke-dasharray: 5, 5;
            fill: none;
            pointer-events: none;
        }

        .connection-preview {
            stroke: var(--accent);
            stroke-width: 3;
            stroke-dasharray: 8, 4;
            fill: none;
            pointer-events: none;
            opacity: 0.8;
        }

        /* è¿æ¥æç¤º */
        .connect-hint {
            position: absolute;
            background: var(--bg-secondary);
            padding: 8px 16px;
            border-radius: 8px;
            font-size: 13px;
            color: var(--text-secondary);
            pointer-events: none;
            z-index: 50;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }

        /* è¿æ¥æ¶ˆæ¯ Modal */
        .message-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .message-modal.show {
            display: flex;
        }

        .message-modal .modal {
            width: 450px;
        }

        .message-modal textarea {
            width: 100%;
            min-height: 100px;
            padding: 12px;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            background: var(--bg-primary);
            color: var(--text-primary);
            font-size: 14px;
            resize: vertical;
            margin-bottom: 16px;
        }

        .message-modal textarea:focus {
            outline: none;
            border-color: var(--accent);
        }

        .connection-preview-area {
            background: var(--bg-tertiary);
            padding: 12px;
            border-radius: 8px;
            margin-bottom: 16px;
            font-size: 13px;
        }

        .connection-preview-from {
            color: var(--accent);
            font-weight: 500;
        }

        .connection-preview-to {
            color: var(--success);
            font-weight: 500;
        }

        /* åŠ¨ç”» */
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .pulse {
            animation: pulse 2s infinite;
        }

        @keyframes flow {
            0% { stroke-dashoffset: 20; }
            100% { stroke-dashoffset: 0; }
        }

        .flowing {
            stroke-dasharray: 10, 10;
            animation: flow 1s linear infinite;
        }

        /* API Key Modal */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .modal-overlay.show {
            display: flex;
        }

        .modal {
            background: var(--bg-secondary);
            border-radius: 16px;
            width: 500px;
            max-height: 80vh;
            overflow: hidden;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 20px;
            border-bottom: 1px solid var(--border-color);
        }

        .modal-header h2 {
            font-size: 18px;
            font-weight: 600;
        }

        .modal-close {
            background: none;
            border: none;
            color: var(--text-secondary);
            font-size: 24px;
            cursor: pointer;
            line-height: 1;
        }

        .modal-close:hover {
            color: var(--text-primary);
        }

        .modal-body {
            padding: 20px;
            max-height: 60vh;
            overflow-y: auto;
        }

        .api-provider {
            background: var(--bg-tertiary);
            border-radius: 12px;
            padding: 16px;
            margin-bottom: 16px;
        }

        .provider-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }

        .provider-name {
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .provider-status {
            width: 8px;
            height: 8px;
            border-radius: 50%;
        }

        .provider-status.active {
            background: var(--success);
            box-shadow: 0 0 8px var(--success);
        }

        .provider-status.inactive {
            background: var(--waiting);
        }

        .api-input {
            width: 100%;
            padding: 10px 12px;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            background: var(--bg-primary);
            color: var(--text-primary);
            font-size: 13px;
            font-family: monospace;
        }

        .api-input:focus {
            outline: none;
            border-color: var(--accent);
        }

        .api-input::placeholder {
            color: var(--text-secondary);
        }

        .provider-actions {
            display: flex;
            gap: 8px;
            margin-top: 12px;
        }

        .btn-small {
            padding: 6px 12px;
            font-size: 12px;
            border-radius: 6px;
        }

        .modal-footer {
            padding: 16px 20px;
            border-top: 1px solid var(--border-color);
            display: flex;
            justify-content: flex-end;
            gap: 10px;
        }

        .api-key-list {
            margin-top: 12px;
        }

        .api-key-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 12px;
            background: var(--bg-primary);
            border-radius: 6px;
            margin-bottom: 6px;
            font-size: 12px;
        }

        .api-key-name {
            color: var(--text-secondary);
        }

        .api-key-preview {
            font-family: monospace;
            color: var(--text-secondary);
        }

        .api-key-delete {
            background: none;
            border: none;
            color: var(--error);
            cursor: pointer;
            font-size: 14px;
            padding: 4px;
        }

        .empty-keys {
            text-align: center;
            padding: 20px;
            color: var(--text-secondary);
            font-size: 13px;
        }

        /* AI å¯¹è¯é¢æ¿ */
        .ai-chat-panel {
            margin-top: 20px;
            border-top: 1px solid var(--border-color);
            padding-top: 16px;
        }

        .ai-chat-title {
            font-size: 14px;
            font-weight: 600;
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .ai-model-select {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            background: var(--bg-primary);
            color: var(--text-primary);
            font-size: 13px;
            margin-bottom: 12px;
            cursor: pointer;
        }

        .ai-model-select:focus {
            outline: none;
            border-color: var(--accent);
        }

        .ai-chat-messages {
            max-height: 200px;
            overflow-y: auto;
            margin-bottom: 12px;
        }

        .ai-message {
            padding: 10px 12px;
            border-radius: 8px;
            margin-bottom: 8px;
            font-size: 13px;
            line-height: 1.5;
        }

        .ai-message-user {
            background: var(--accent);
            color: white;
            margin-left: 20px;
        }

        .ai-message-ai {
            background: var(--bg-tertiary);
            color: var(--text-primary);
            margin-right: 20px;
        }

        .ai-chat-input {
            display: flex;
            gap: 8px;
        }

        .ai-chat-input input {
            flex: 1;
            padding: 10px 12px;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            background: var(--bg-primary);
            color: var(--text-primary);
            font-size: 13px;
        }

        .ai-chat-input input:focus {
            outline: none;
            border-color: var(--accent);
        }

        .ai-chat-input button {
            padding: 10px 16px;
            border: none;
            border-radius: 8px;
            background: var(--accent);
            color: white;
            cursor: pointer;
            font-size: 13px;
        }

        .ai-chat-input button:hover {
            background: var(--accent-hover);
        }

        .ai-chat-input button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .model-badge {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 11px;
            margin-left: 8px;
        }

        .model-badge-openai { background: #10a98120; color: #10a981; }
        .model-badge-anthropic { background: #d9770620; color: #d97706; }
        .model-badge-google { background: #4285f420; color: #4285f4; }
        .model-badge-ollama { background: #8b5cf620; color: #8b5cf6; }
    </style>
</head>
<body>
    <!-- é¡¶éƒ¨æ§åˆ¶æ  -->
    <header class="control-bar">
        <h1>ğŸ¤– Agent Visualizer</h1>
        <div class="controls">
            <button class="btn btn-secondary" onclick="exportPNG()">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
                    <polyline points="7 10 12 15 17 10"/>
                    <line x1="12" y1="15" x2="12" y2="3"/>
                </svg>
                å¯¼å‡º PNG
            </button>
            <button class="btn btn-secondary" onclick="exportJSON()">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/>
                    <polyline points="14 2 14 8 20 8"/>
                </svg>
                å¯¼å‡º JSON
            </button>
            <button class="btn btn-primary" onclick="toggle3DView()" id="viewToggle">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M12 2L2 7l10 5 10-5-10-5z"/>
                    <path d="M2 17l10 5 10-5"/>
                    <path d="M2 12l10 5 10-5"/>
                </svg>
                3D è§†å›¾
            </button>
            <button class="btn btn-secondary" onclick="openApiKeysModal()">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M21 2l-2 2m-7.61 7.61a5.5 5.5 0 1 1-7.778 7.778 5.5 5.5 0 0 1 7.777-7.777zm0 0L15.5 7.5m0 0l3 3L22 7l-3-3m-3.5 3.5L19 4"/>
                </svg>
                API å¯†é’¥
            </button>
        </div>
    </header>

    <div class="main-container">
        <!-- å·¦ä¾§ Agent åˆ—è¡¨ -->
        <aside class="agent-list">
            <h2>Agent åˆ—è¡¨</h2>
            <div id="agentList"></div>
            <button class="add-agent-btn" onclick="addNewAgent()">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="display:inline;vertical-align:middle;margin-right:8px">
                    <line x1="12" y1="5" x2="12" y2="19"/>
                    <line x1="5" y1="12" x2="19" y2="12"/>
                </svg>
                æ·»åŠ  Agent
            </button>

            <!-- æ‹–æ‹½è§’è‰²å¡ç‰Œ -->
            <div class="role-cards">
                <div class="role-cards-title">ğŸ‘‡ æ‹–æ‹½è§’è‰²åˆ›å»º Agent</div>
                <div id="roleCards"></div>
            </div>
        </aside>

        <!-- ä¸­é—´å¯è§†åŒ–åŒºåŸŸ -->
        <main class="visualization" id="visualization">
            <div class="drop-indicator" id="dropIndicator">+</div>
            <canvas id="threeCanvas" style="display:none; width:100%; height:100%;"></canvas>
            <svg id="flowCanvas" width="100%" height="100%">
                <defs>
                    <marker id="arrowhead" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
                        <polygon points="0 0, 10 3.5, 0 7" fill="#8b5cf6"/>
                    </marker>
                    <linearGradient id="lineGradient" x1="0%" y1="0%" x2="100%" y2="0%">
                        <stop offset="0%" style="stop-color:#8b5cf6;stop-opacity:1" />
                        <stop offset="100%" style="stop-color:#ec4899;stop-opacity:1" />
                    </linearGradient>
                </defs>
                <g id="connections"></g>
                <g id="nodes"></g>
            </svg>
            <div class="empty-state" id="emptyState">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                    <circle cx="12" cy="12" r="3"/>
                    <circle cx="4" cy="6" r="2"/>
                    <circle cx="20" cy="6" r="2"/>
                    <circle cx="4" cy="18" r="2"/>
                    <circle cx="20" cy="18" r="2"/>
                    <line x1="6" y1="6" x2="9" y2="10"/>
                    <line x1="18" y1="6" x2="15" y2="10"/>
                    <line x1="6" y1="18" x2="9" y2="14"/>
                    <line x1="18" y1="18" x2="15" y2="14"/>
                </svg>
                <p>ç‚¹å‡»"æ·»åŠ  Agent"å¼€å§‹åˆ›å»ºå·¥ä½œæµç¨‹</p>
            </div>
            <div class="view-hint" id="viewHint">
                ğŸ–±ï¸ æ‹–æ‹½æ—‹è½¬ | æ»šè½®ç¼©æ”¾ | å³é”®å¹³ç§»
            </div>
            <!-- æ—¶é—´çº¿ -->
            <div class="timeline">
                <button class="timeline-btn" onclick="skipToStart()" title="è·³åˆ°å¼€å§‹">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
                        <polygon points="19 20 9 12 19 4 19 20"/>
                        <line x1="5" y1="19" x2="5" y2="5" stroke="currentColor" stroke-width="2"/>
                    </svg>
                </button>
                <button class="timeline-btn" onclick="stepBackward()" title="ä¸Šä¸€æ­¥">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
                        <polygon points="11 19 2 12 11 5 11 19"/>
                        <polygon points="22 19 13 12 22 5 22 19"/>
                    </svg>
                </button>
                <button class="timeline-btn" id="playBtn" onclick="togglePlay()" title="æ’­æ”¾/æš‚åœ">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor" id="playIcon">
                        <polygon points="5 3 19 12 5 21 5 3"/>
                    </svg>
                </button>
                <button class="timeline-btn" onclick="stepForward()" title="ä¸‹ä¸€æ­¥">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
                        <polygon points="13 19 22 12 13 5 13 19"/>
                        <polygon points="2 19 11 12 2 5 2 19"/>
                    </svg>
                </button>
                <button class="timeline-btn" onclick="skipToEnd()" title="è·³åˆ°ç»“æŸ">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
                        <polygon points="5 4 15 12 5 20 5 4"/>
                        <line x1="19" y1="5" x2="19" y2="19" stroke="currentColor" stroke-width="2"/>
                    </svg>
                </button>
                <div class="timeline-progress" onclick="seekTimeline(event)">
                    <div class="timeline-progress-bar" id="progressBar"></div>
                </div>
                <span class="timeline-time" id="timelineTime">0:00 / 0:00</span>
            </div>
        </main>

        <!-- å³ä¾§è¯¦æƒ…é¢æ¿ -->
        <aside class="details-panel" id="detailsPanel">
            <div class="panel-header">
                <h2>è¯¦ç»†ä¿¡æ¯</h2>
                <button class="close-btn" onclick="closeDetails()">Ã—</button>
            </div>
            <div id="panelContent">
                <p style="color: var(--text-secondary); text-align: center; padding: 40px 0;">
                    é€‰æ‹©ä¸€ä¸ª Agent æŸ¥çœ‹è¯¦æƒ…
                </p>
            </div>
        </aside>
    </div>

    <!-- API Keys Modal -->
    <div class="modal-overlay" id="apiKeysModal">
        <div class="modal">
            <div class="modal-header">
                <h2>ğŸ”‘ API å¯†é’¥ç®¡ç†</h2>
                <button class="modal-close" onclick="closeApiKeysModal()">Ã—</button>
            </div>
            <div class="modal-body">
                <p style="color: var(--text-secondary); font-size: 13px; margin-bottom: 16px;">
                    é…ç½®æ‚¨çš„ AI æœåŠ¡ API å¯†é’¥ï¼Œæ”¯æŒå¤šç§æ¨¡å‹æä¾›å•†ã€‚å¯†é’¥å­˜å‚¨åœ¨æœ¬åœ°æµè§ˆå™¨ä¸­ï¼Œä¸ä¼šå‘é€åˆ°ä»»ä½•æœåŠ¡å™¨ã€‚
                </p>

                <!-- OpenAI -->
                <div class="api-provider">
                    <div class="provider-header">
                        <span class="provider-name">
                            <span class="provider-status" id="openaiStatus"></span>
                            OpenAI (GPT-4o, GPT-4o mini)
                        </span>
                    </div>
                    <input type="password" class="api-input" id="openaiKey" placeholder="sk-..." oninput="updateKeyStatus('openai')">
                    <div class="provider-actions">
                        <button class="btn btn-success btn-small" onclick="saveApiKey('openai')">ä¿å­˜</button>
                        <button class="btn btn-secondary btn-small" onclick="testApiKey('openai')">æµ‹è¯•</button>
                    </div>
                    <div class="api-key-list" id="openaiKeysList"></div>
                </div>

                <!-- Anthropic -->
                <div class="api-provider">
                    <div class="provider-header">
                        <span class="provider-name">
                            <span class="provider-status" id="anthropicStatus"></span>
                            Anthropic (Claude)
                        </span>
                    </div>
                    <input type="password" class="api-input" id="anthropicKey" placeholder="sk-ant-..." oninput="updateKeyStatus('anthropic')">
                    <div class="provider-actions">
                        <button class="btn btn-success btn-small" onclick="saveApiKey('anthropic')">ä¿å­˜</button>
                        <button class="btn btn-secondary btn-small" onclick="testApiKey('anthropic')">æµ‹è¯•</button>
                    </div>
                    <div class="api-key-list" id="anthropicKeysList"></div>
                </div>

                <!-- Google -->
                <div class="api-provider">
                    <div class="provider-header">
                        <span class="provider-name">
                            <span class="provider-status" id="googleStatus"></span>
                            Google (Gemini)
                        </span>
                    </div>
                    <input type="password" class="api-input" id="googleKey" placeholder="AIza..." oninput="updateKeyStatus('google')">
                    <div class="provider-actions">
                        <button class="btn btn-success btn-small" onclick="saveApiKey('google')">ä¿å­˜</button>
                        <button class="btn btn-secondary btn-small" onclick="testApiKey('google')">æµ‹è¯•</button>
                    </div>
                    <div class="api-key-list" id="googleKeysList"></div>
                </div>

                <!-- Ollama -->
                <div class="api-provider">
                    <div class="provider-header">
                        <span class="provider-name">
                            <span class="provider-status" id="ollamaStatus"></span>
                            Ollama (æœ¬åœ°æ¨¡å‹)
                        </span>
                    </div>
                    <input type="text" class="api-input" id="ollamaUrl" placeholder="http://localhost:11434" value="http://localhost:11434" oninput="updateKeyStatus('ollama')">
                    <div class="provider-actions">
                        <button class="btn btn-success btn-small" onclick="saveApiKey('ollama')">ä¿å­˜</button>
                        <button class="btn btn-secondary btn-small" onclick="testApiKey('ollama')">æµ‹è¯•</button>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-secondary" onclick="closeApiKeysModal()">å…³é—­</button>
                <button class="btn btn-primary" onclick="exportKeys()">å¯¼å‡ºå¯†é’¥</button>
            </div>
        </div>
    </div>

    <!-- è¿æ¥æ¶ˆæ¯ Modal -->
    <div class="message-modal" id="messageModal">
        <div class="modal">
            <div class="modal-header">
                <h2>ğŸ“ åˆ›å»ºæ¶ˆæ¯è¿æ¥</h2>
                <button class="modal-close" onclick="closeMessageModal()">Ã—</button>
            </div>
            <div class="modal-body">
                <div class="connection-preview-area">
                    <span class="connection-preview-from" id="connFromName"></span>
                    <span> â†’ </span>
                    <span class="connection-preview-to" id="connToName"></span>
                </div>
                <textarea id="messageContent" placeholder="è¾“å…¥æ¶ˆæ¯å†…å®¹..."></textarea>
            </div>
            <div class="modal-footer">
                <button class="btn btn-secondary" onclick="closeMessageModal()">å–æ¶ˆ</button>
                <button class="btn btn-primary" onclick="createConnection()">åˆ›å»ºè¿æ¥</button>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
        <script>
        // Three.js 3D åœºæ™¯å˜é‡
        let scene, camera, renderer, controls;
        let agentMeshes = [];
        let messageParticles = [];
        let is3DMode = false;
        let animationClock;

        // Agent æ•°æ®
        let agents = [];
        let messages = [];
        let selectedAgent = null;
        let isPlaying = false;
        let currentTime = 0;
        let animationId = null;

        // Agent è§’è‰²é…ç½®
        const agentRoles = {
            'CEO': { icon: 'ğŸ‘”', color: '#8b5cf6', role: 'å†³ç­–è€…' },
            'CTO': { icon: 'ğŸ’»', color: '#3b82f6', role: 'æŠ€æœ¯ä¸»ç®¡' },
            'Researcher': { icon: 'ğŸ”', color: '#10b981', role: 'ç ”ç©¶å‘˜' },
            'Designer': { icon: 'ğŸ¨', color: '#ec4899', role: 'è®¾è®¡å¸ˆ' },
            'Developer': { icon: 'âš¡', color: '#f59e0b', role: 'å¼€å‘è€…' },
            'QA': { icon: 'ğŸ§ª', color: '#06b6d4', role: 'æµ‹è¯•å·¥ç¨‹å¸ˆ' },
            'Marketing': { icon: 'ğŸ“¢', color: '#ef4444', role: 'å¸‚åœºæ€»ç›‘' },
            'Sales': { icon: 'ğŸ’°', color: '#84cc16', role: 'é”€å”®æ€»ç›‘' }
        };

        // æ‹–æ‹½ç›¸å…³å˜é‡
        let draggedRole = null;
        let dragOverX = 0;
        let dragOverY = 0;

        // è¿æ¥ç›¸å…³å˜é‡
        let isConnecting = false;
        let connectFromAgent = null;
        let connectionLine = null;

        // æ¸²æŸ“è§’è‰²å¡ç‰Œï¼ˆç”¨äºæ‹–æ‹½ï¼‰
        function renderRoleCards() {
            const container = document.getElementById('roleCards');
            const roles = Object.entries(agentRoles);

            container.innerHTML = roles.map(([key, value]) => `
                <div class="role-card" draggable="true" data-role="${key}">
                    <div class="role-card-icon" style="background: ${value.color}20; color: ${value.color}">
                        ${value.icon}
                    </div>
                    <div class="role-card-info">
                        <div class="role-card-name">${key}</div>
                        <div class="role-card-role">${value.role}</div>
                    </div>
                </div>
            `).join('');

            // æ·»åŠ æ‹–æ‹½äº‹ä»¶ç›‘å¬
            document.querySelectorAll('.role-card').forEach(card => {
                card.addEventListener('dragstart', handleDragStart);
                card.addEventListener('dragend', handleDragEnd);
            });
        }

        // æ‹–æ‹½å¼€å§‹
        function handleDragStart(e) {
            draggedRole = e.target.dataset.role;
            e.target.classList.add('dragging');
            e.dataTransfer.effectAllowed = 'copy';
            e.dataTransfer.setData('text/plain', draggedRole);

            // æ˜¾ç¤ºæ”¾ç½®åŒºåŸŸ
            const visualization = document.getElementById('visualization');
            visualization.classList.add('drag-over');
        }

        // æ‹–æ‹½ç»“æŸ
        function handleDragEnd(e) {
            e.target.classList.remove('dragging');
            draggedRole = null;

            // éšè—æ”¾ç½®åŒºåŸŸ
            const visualization = document.getElementById('visualization');
            visualization.classList.remove('drag-over');
            document.getElementById('dropIndicator').classList.remove('show');
        }

        // å¯è§†åŒ–åŒºåŸŸæ‹–æ‹½äº‹ä»¶
        const visualization = document.getElementById('visualization');

        visualization.addEventListener('dragover', function(e) {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'copy';

            // æ›´æ–°æ”¾ç½®æŒ‡ç¤ºå™¨ä½ç½®
            const rect = visualization.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            const indicator = document.getElementById('dropIndicator');
            indicator.style.left = (x - 40) + 'px';
            indicator.style.top = (y - 40) + 'px';
            indicator.classList.add('show');

            visualization.classList.add('drag-over');
        });

        visualization.addEventListener('dragleave', function(e) {
            if (!visualization.contains(e.relatedTarget)) {
                visualization.classList.remove('drag-over');
                document.getElementById('dropIndicator').classList.remove('show');
            }
        });

        visualization.addEventListener('drop', function(e) {
            e.preventDefault();
            visualization.classList.remove('drag-over');
            document.getElementById('dropIndicator').classList.remove('show');

            const role = e.dataTransfer.getData('text/plain') || draggedRole;
            if (!role || !agentRoles[role]) return;

            // è®¡ç®—æ”¾ç½®ä½ç½®
            const rect = visualization.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            // åˆ›å»ºæ–° Agent
            const newId = Math.max(...agents.map(a => a.id), 0) + 1;
            const roleInfo = agentRoles[role];
            const newAgent = {
                id: newId,
                name: role,
                role: role,
                status: 'waiting',
                x: x,
                y: y
            };
            agents.push(newAgent);

            // å¦‚æœåœ¨ 3D æ¨¡å¼ï¼Œæ›´æ–° 3D åœºæ™¯
            if (is3DMode && scene) {
                updateAgentMeshes();
                updateMessageParticles();
            }

            renderAgents();
            renderFlow();
            selectAgent(newId);

            showNotification(`å·²åˆ›å»º ${roleInfo.role}: ${role}`, 'success');
        });

        // åˆå§‹åŒ–ç¤ºä¾‹æ•°æ®
        function initDemo() {
            agents = [
                { id: 1, name: 'Bezos', role: 'CEO', status: 'running', x: 400, y: 300 },
                { id: 2, name: 'Vogels', role: 'CTO', status: 'waiting', x: 200, y: 150 },
                { id: 3, name: 'Thompson', role: 'Researcher', status: 'completed', x: 200, y: 450 },
                { id: 4, name: 'Duarte', role: 'Designer', status: 'waiting', x: 600, y: 150 },
                { id: 5, name: 'Bach', role: 'QA', status: 'waiting', x: 600, y: 450 }
            ];

            messages = [
                { from: 1, to: 2, content: 'åˆ†ææ–°é¡¹ç›®æŠ€æœ¯æ–¹æ¡ˆ', time: '10:00' },
                { from: 1, to: 3, content: 'è°ƒç ”å¸‚åœºè§„æ¨¡', time: '10:05' },
                { from: 2, to: 4, content: 'éœ€è¦UIè®¾è®¡ç¨¿', time: '10:15' },
                { from: 3, to: 1, content: 'å¸‚åœºè§„æ¨¡è°ƒç ”å®Œæˆ', time: '10:30' },
                { from: 4, to: 1, content: 'è®¾è®¡ç¨¿å·²å®Œæˆ', time: '10:45' },
                { from: 1, to: 5, content: 'å‡†å¤‡æµ‹è¯•è®¡åˆ’', time: '11:00' }
            ];

            renderAgents();
            renderRoleCards();
            renderFlow();
            updateTimeline();
        }

        // æ¸²æŸ“ Agent åˆ—è¡¨
        function renderAgents() {
            const list = document.getElementById('agentList');
            list.innerHTML = agents.map(agent => `
                <div class="agent-item ${selectedAgent === agent.id ? 'active' : ''}" onclick="selectAgent(${agent.id})">
                    <div class="agent-avatar" style="background: ${agentRoles[agent.role]?.color || '#6b7280'}20; color: ${agentRoles[agent.role]?.color || '#6b7280'}">
                        ${agentRoles[agent.role]?.icon || 'ğŸ¤–'}
                    </div>
                    <div class="agent-info">
                        <div class="agent-name">${agent.name}</div>
                        <div class="agent-role">${agentRoles[agent.role]?.role || agent.role}</div>
                    </div>
                    <div class="agent-status status-${agent.status}"></div>
                </div>
            `).join('');
        }

        // æ¸²æŸ“æµç¨‹å›¾
        function renderFlow() {
            const nodesGroup = document.getElementById('nodes');
            const connectionsGroup = document.getElementById('connections');
            const emptyState = document.getElementById('emptyState');

            if (agents.length === 0) {
                emptyState.style.display = 'block';
                nodesGroup.innerHTML = '';
                connectionsGroup.innerHTML = '';
                return;
            }

            emptyState.style.display = 'none';

            // ç»˜åˆ¶è¿çº¿
            connectionsGroup.innerHTML = messages.map((msg, idx) => {
                const fromAgent = agents.find(a => a.id === msg.from);
                const toAgent = agents.find(a => a.id === msg.to);
                if (!fromAgent || !toAgent) return '';

                return `
                    <line
                        x1="${fromAgent.x}" y1="${fromAgent.y}"
                        x2="${toAgent.x}" y2="${toAgent.y}"
                        stroke="url(#lineGradient)"
                        stroke-width="2"
                        marker-end="url(#arrowhead)"
                        class="flowing"
                        style="animation-delay: ${idx * 0.5}s"
                    />
                `;
            }).join('');

            // ç»˜åˆ¶èŠ‚ç‚¹
            nodesGroup.innerHTML = agents.map(agent => {
                const role = agentRoles[agent.role] || { color: '#6b7280', icon: 'ğŸ¤–' };
                return `
                    <g class="agent-node" onclick="selectAgent(${agent.id})" onmousedown="startConnection(event, ${agent.id})" style="cursor: pointer">
                        <circle
                            cx="${agent.x}" cy="${agent.y}" r="35"
                            fill="${role.color}20"
                            stroke="${role.color}"
                            stroke-width="2"
                        />
                        <text x="${agent.x}" y="${agent.y - 5}" text-anchor="middle" fill="${role.color}" font-size="20">
                            ${role.icon}
                        </text>
                        <text x="${agent.x}" y="${agent.y + 18}" text-anchor="middle" fill="#f1f5f9" font-size="12" font-weight="500">
                            ${agent.name}
                        </text>
                        <circle
                            cx="${agent.x + 25}" cy="${agent.y - 25}" r="8"
                            fill="${getStatusColor(agent.status)}"
                            stroke="#1e293b"
                            stroke-width="2"
                        />
                        <!-- è¿æ¥ç‚¹ -->
                        <circle cx="${agent.x + 35}" cy="${agent.y}" r="6" fill="var(--accent)" opacity="0" class="connect-point">
                            <title>æ‹–æ‹½åˆ›å»ºè¿æ¥</title>
                        </circle>
                    </g>
                `;
            }).join('');
        }

        function getStatusColor(status) {
            const colors = {
                'running': '#22c55e',
                'waiting': '#eab308',
                'completed': '#6b7280',
                'failed': '#ef4444'
            };
            return colors[status] || '#6b7280';
        }

        // ======== æ‹–æ‹½è¿æ¥åŠŸèƒ½ ========

        // å¼€å§‹è¿æ¥
        function startConnection(event, agentId) {
            // å¦‚æœæ˜¯ç‚¹å‡»èŠ‚ç‚¹ä¸Šçš„ç‰¹å®šåŒºåŸŸï¼ˆå¦‚çŠ¶æ€çƒï¼‰ï¼Œä¸å¯åŠ¨è¿æ¥
            if (event.target.classList.contains('connect-point') || event.target.tagName === 'circle') {
                event.preventDefault();
                isConnecting = true;
                connectFromAgent = agentId;

                // åˆ›å»ºè¿æ¥çº¿
                const connectionsGroup = document.getElementById('connections');
                const svg = document.getElementById('flowCanvas');
                const rect = svg.getBoundingClientRect();

                const agent = agents.find(a => a.id === agentId);
                connectionLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                connectionLine.setAttribute('x1', agent.x);
                connectionLine.setAttribute('y1', agent.y);
                connectionLine.setAttribute('x2', agent.x);
                connectionLine.setAttribute('y2', agent.y);
                connectionLine.setAttribute('class', 'connection-preview');
                connectionsGroup.appendChild(connectionLine);

                // æ·»åŠ å…¨å±€é¼ æ ‡äº‹ä»¶
                document.addEventListener('mousemove', updateConnectionLine);
                document.addEventListener('mouseup', endConnection);

                // é˜»æ­¢äº‹ä»¶ä¼ æ’­
                event.stopPropagation();
            }
        }

        // æ›´æ–°è¿æ¥çº¿
        function updateConnectionLine(event) {
            if (!isConnecting || !connectionLine) return;

            const svg = document.getElementById('flowCanvas');
            const rect = svg.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;

            connectionLine.setAttribute('x2', x);
            connectionLine.setAttribute('y2', y);
        }

        // ç»“æŸè¿æ¥
        function endConnection(event) {
            if (!isConnecting) return;

            // ç§»é™¤äº‹ä»¶ç›‘å¬
            document.removeEventListener('mousemove', updateConnectionLine);
            document.removeEventListener('mouseup', endConnection);

            // æ£€æŸ¥æ˜¯å¦é‡Šæ”¾ç›®æ ‡æ˜¯ä¸€ä¸ª Agent
            const svg = document.getElementById('flowCanvas');
            const rect = svg.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;

            // æŸ¥æ‰¾ç›®æ ‡ Agent
            const targetAgent = agents.find(agent => {
                const dx = agent.x - x;
                const dy = agent.y - y;
                return Math.sqrt(dx * dx + dy * dy) < 40;
            });

            if (targetAgent && targetAgent.id !== connectFromAgent) {
                // æ‰“å¼€æ¶ˆæ¯è¾“å…¥æ¡†
                openMessageModal(connectFromAgent, targetAgent.id);
            }

            // ç§»é™¤è¿æ¥çº¿
            if (connectionLine) {
                connectionLine.remove();
                connectionLine = null;
            }

            isConnecting = false;
            connectFromAgent = null;
        }

        // æ‰“å¼€æ¶ˆæ¯è¾“å…¥æ¡†
        function openMessageModal(fromId, toId) {
            const fromAgent = agents.find(a => a.id === fromId);
            const toAgent = agents.find(a => a.id === toId);

            document.getElementById('connFromName').textContent = fromAgent.name;
            document.getElementById('connToName').textContent = toAgent.name;
            document.getElementById('messageContent').value = '';
            document.getElementById('messageModal').classList.add('show');

            // å­˜å‚¨è¿æ¥ä¿¡æ¯
            document.getElementById('messageModal').dataset.fromId = fromId;
            document.getElementById('messageModal').dataset.toId = toId;

            document.getElementById('messageContent').focus();
        }

        // å…³é—­æ¶ˆæ¯è¾“å…¥æ¡†
        function closeMessageModal() {
            document.getElementById('messageModal').classList.remove('show');
        }

        // åˆ›å»ºè¿æ¥
        function createConnection() {
            const modal = document.getElementById('messageModal');
            const fromId = parseInt(modal.dataset.fromId);
            const toId = parseInt(modal.dataset.toId);
            const content = document.getElementById('messageContent').value.trim();

            if (!content) {
                alert('è¯·è¾“å…¥æ¶ˆæ¯å†…å®¹');
                return;
            }

            // åˆ›å»ºæ–°æ¶ˆæ¯
            const newMessage = {
                from: fromId,
                to: toId,
                content: content,
                time: new Date().toLocaleTimeString('zh-CN', { hour: '2-digit', minute: '2-digit' })
            };
            messages.push(newMessage);

            // æ›´æ–°æ˜¾ç¤º
            renderFlow();
            updateTimeline();

            closeMessageModal();
            showNotification('æ¶ˆæ¯è¿æ¥å·²åˆ›å»º', 'success');
        }

        // ç‚¹å‡»æ¨¡æ€æ¡†å¤–éƒ¨å…³é—­
        document.getElementById('messageModal').addEventListener('click', function(e) {
            if (e.target === this) {
                closeMessageModal();
            }
        });

        // ======== ç»“æŸæ‹–æ‹½è¿æ¥åŠŸèƒ½ ========

        // é€‰æ‹© Agent
        function selectAgent(id) {
            selectedAgent = id;
            renderAgents();
            renderDetails();
        }

        // æ¸²æŸ“è¯¦æƒ…é¢æ¿
        // å¯ç”¨æ¨¡å‹é…ç½®
        const availableModels = {
            openai: [
                { id: 'gpt-4o', name: 'GPT-4o' },
                { id: 'gpt-4o-mini', name: 'GPT-4o mini' },
                { id: 'gpt-4-turbo', name: 'GPT-4 Turbo' }
            ],
            anthropic: [
                { id: 'claude-3-5-sonnet-20241022', name: 'Claude 3.5 Sonnet' },
                { id: 'claude-3-opus-20240229', name: 'Claude 3 Opus' },
                { id: 'claude-3-haiku-20240307', name: 'Claude 3 Haiku' }
            ],
            google: [
                { id: 'gemini-1.5-pro', name: 'Gemini 1.5 Pro' },
                { id: 'gemini-1.5-flash', name: 'Gemini 1.5 Flash' },
                { id: 'gemini-1.0-pro', name: 'Gemini 1.0 Pro' }
            ],
            ollama: [
                { id: 'llama2', name: 'Llama 2' },
                { id: 'mistral', name: 'Mistral' },
                { id: 'qwen', name: 'Qwen' },
                { id: 'deepseek', name: 'DeepSeek' }
            ]
        };

        // Agent å¯¹è¯å†å²
        let agentChats = {};

        function getModelBadgeClass(provider) {
            return 'model-badge model-badge-' + provider;
        }

        function getProviderFromModel(modelId) {
            if (availableModels.openai.some(m => m.id === modelId)) return 'openai';
            if (availableModels.anthropic.some(m => m.id === modelId)) return 'anthropic';
            if (availableModels.google.some(m => m.id === modelId)) return 'google';
            return 'ollama';
        }

        function renderDetails() {
            const panel = document.getElementById('panelContent');
            const agent = agents.find(a => a.id === selectedAgent);

            if (!agent) {
                panel.innerHTML = `
                    <p style="color: var(--text-secondary); text-align: center; padding: 40px 0;">
                        é€‰æ‹©ä¸€ä¸ª Agent æŸ¥çœ‹è¯¦æƒ…
                    </p>
                `;
                return;
            }

            // åˆå§‹åŒ– agent çš„å¯¹è¯å†å²
            if (!agentChats[agent.id]) {
                agentChats[agent.id] = [];
            }

            const role = agentRoles[agent.role] || { role: agent.role };
            const agentMessages = messages.filter(m => m.from === agent.id || m.to === agent.id);
            const currentModel = agent.model || 'gpt-4o-mini';
            const currentProvider = getProviderFromModel(currentModel);

            // ç”Ÿæˆæ¨¡å‹é€‰é¡¹
            let modelOptions = '';
            for (const [provider, models] of Object.entries(availableModels)) {
                const hasKeys = apiKeys[provider] && apiKeys[provider].length > 0;
                const disabled = !hasKeys && provider !== 'ollama';
                modelOptions += `<optgroup label="${provider.toUpperCase()}" ${disabled ? 'disabled' : ''}>`;
                models.forEach(m => {
                    const selected = m.id === currentModel ? 'selected' : '';
                    modelOptions += `<option value="${m.id}" ${selected}>${m.name}</option>`;
                });
                modelOptions += '</optgroup>';
            }

            panel.innerHTML = `
                <div class="detail-section">
                    <h3>åŸºæœ¬ä¿¡æ¯</h3>
                    <div class="detail-item">
                        <span class="detail-label">åç§°</span>
                        <span class="detail-value">${agent.name}</span>
                    </div>
                    <div class="detail-item">
                        <span class="detail-label">è§’è‰²</span>
                        <span class="detail-value">${role.role}</span>
                    </div>
                    <div class="detail-item">
                        <span class="detail-label">çŠ¶æ€</span>
                        <span class="detail-value" style="color: ${getStatusColor(agent.status)}">
                            ${getStatusText(agent.status)}
                        </span>
                    </div>
                    <div class="detail-item">
                        <span class="detail-label">AI æ¨¡å‹</span>
                        <span class="detail-value">
                            ${availableModels[currentProvider]?.find(m => m.id === currentModel)?.name || currentModel}
                            <span class="${getModelBadgeClass(currentProvider)}">${currentProvider.toUpperCase()}</span>
                        </span>
                    </div>
                </div>
                <div class="detail-section">
                    <h3>æ¶ˆæ¯å†å² (${agentMessages.length})</h3>
                    <div class="message-list">
                        ${agentMessages.length > 0 ? agentMessages.map(msg => {
                            const fromAgent = agents.find(a => a.id === msg.from);
                            const toAgent = agents.find(a => a.id === msg.to);
                            return `
                                <div class="message-item">
                                    <div class="message-header">
                                        <span>
                                            <span class="message-from">${fromAgent?.name || 'æœªçŸ¥'}</span>
                                            â†’
                                            <span class="message-to">${toAgent?.name || 'æœªçŸ¥'}</span>
                                        </span>
                                        <span class="message-time">${msg.time}</span>
                                    </div>
                                    <div class="message-content">${msg.content}</div>
                                </div>
                            `;
                        }).join('') : '<p style="color: var(--text-secondary); font-size: 13px;">æš‚æ— æ¶ˆæ¯</p>'}
                    </div>
                </div>
                <div class="ai-chat-panel">
                    <div class="ai-chat-title">
                        <span>ğŸ¤– AI å¯¹è¯</span>
                    </div>
                    <select class="ai-model-select" id="modelSelect" onchange="changeAgentModel(${agent.id})">
                        ${modelOptions}
                    </select>
                    <div class="ai-chat-messages" id="chatMessages">
                        ${agentChats[agent.id].map(chat => `
                            <div class="ai-message ${chat.role === 'user' ? 'ai-message-user' : 'ai-message-ai'}">
                                ${chat.content}
                            </div>
                        `).join('')}
                    </div>
                    <div class="ai-chat-input">
                        <input type="text" id="chatInput" placeholder="è¾“å…¥æ¶ˆæ¯ä¸ AI å¯¹è¯..." onkeypress="handleChatKeyPress(event, ${agent.id})">
                        <button onclick="sendChatMessage(${agent.id})" id="sendBtn">å‘é€</button>
                    </div>
                </div>
            `;
        }

        function changeAgentModel(agentId) {
            const select = document.getElementById('modelSelect');
            const agent = agents.find(a => a.id === agentId);
            if (agent && select) {
                agent.model = select.value;
                renderDetails();
                showNotification('æ¨¡å‹å·²åˆ‡æ¢', 'success');
            }
        }

        function handleChatKeyPress(event, agentId) {
            if (event.key === 'Enter') {
                sendChatMessage(agentId);
            }
        }

        async function sendChatMessage(agentId) {
            const input = document.getElementById('chatInput');
            const sendBtn = document.getElementById('sendBtn');
            const content = input.value.trim();

            if (!content) return;

            const agent = agents.find(a => a.id === agentId);
            if (!agent) return;

            const model = agent.model || 'gpt-4o-mini';
            const provider = getProviderFromModel(model);

            // æ£€æŸ¥ API Key
            if (!apiKeys[provider] || apiKeys[provider].length === 0) {
                showNotification('è¯·å…ˆé…ç½® ' + provider.toUpperCase() + ' API Key', 'error');
                openApiKeysModal();
                return;
            }

            // æ·»åŠ ç”¨æˆ·æ¶ˆæ¯
            if (!agentChats[agentId]) {
                agentChats[agentId] = [];
            }
            agentChats[agentId].push({ role: 'user', content: content });

            // æ›´æ–° UI
            renderDetails();

            // ç¦ç”¨æŒ‰é’®
            sendBtn.disabled = true;
            sendBtn.textContent = 'å‘é€ä¸­...';

            try {
                const response = await callAIApi(provider, model, agentChats[agentId], agent);
                agentChats[agentId].push({ role: 'assistant', content: response });
            } catch (error) {
                agentChats[agentId].push({ role: 'assistant', content: 'æŠ±æ­‰ï¼Œå‘ç”Ÿé”™è¯¯: ' + error.message });
            }

            // é‡æ–°æ¸²æŸ“
            renderDetails();

            // æ»šåŠ¨åˆ°åº•éƒ¨
            setTimeout(() => {
                const chatMessages = document.getElementById('chatMessages');
                if (chatMessages) {
                    chatMessages.scrollTop = chatMessages.scrollHeight;
                }
            }, 100);
        }

        async function callAIApi(provider, model, conversation, agent) {
            const apiKey = apiKeys[provider][0].key;

            // è½¬æ¢å¯¹è¯æ ¼å¼
            const messages = conversation.map(c => ({
                role: c.role === 'assistant' ? 'assistant' : 'user',
                content: c.content
            }));

            if (provider === 'openai') {
                const response = await fetch('https://api.openai.com/v1/chat/completions', {
                    method: 'POST',
                    headers: {
                        'Authorization': 'Bearer ' + apiKey,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        model: model,
                        messages: messages,
                        max_tokens: 1000
                    })
                });

                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.error?.message || 'API è¯·æ±‚å¤±è´¥');
                }

                const data = await response.json();
                return data.choices[0].message.content;
            }

            if (provider === 'anthropic') {
                const response = await fetch('https://api.anthropic.com/v1/messages', {
                    method: 'POST',
                    headers: {
                        'x-api-key': apiKey,
                        'anthropic-version': '2023-06-01',
                        'content-type': 'application/json'
                    },
                    body: JSON.stringify({
                        model: model,
                        messages: messages,
                        max_tokens: 1000
                    })
                });

                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.error?.message || 'API è¯·æ±‚å¤±è´¥');
                }

                const data = await response.json();
                return data.content[0].text;
            }

            if (provider === 'google') {
                const response = await fetch('https://generativelanguage.googleapis.com/v1/models/' + model + ':generateContent?key=' + apiKey, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        contents: messages.map(m => ({
                            role: m.role === 'user' ? 'user' : 'model',
                            parts: [{ text: m.content }]
                        })),
                        generationConfig: {
                            maxOutputTokens: 1000,
                            temperature: 0.9
                        }
                    })
                });

                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.error?.message || 'API è¯·æ±‚å¤±è´¥');
                }

                const data = await response.json();
                return data.candidates[0].content.parts[0].text;
            }

            if (provider === 'ollama') {
                const response = await fetch(apiKey + '/api/chat', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        model: model,
                        messages: messages,
                        stream: false
                    })
                });

                if (!response.ok) {
                    throw new Error('Ollama è¯·æ±‚å¤±è´¥');
                }

                const data = await response.json();
                return data.message.content;
            }

            throw new Error('ä¸æ”¯æŒçš„ provider: ' + provider);
        }

        function getStatusText(status) {
            const texts = {
                'running': 'è¿è¡Œä¸­',
                'waiting': 'ç­‰å¾…ä¸­',
                'completed': 'å·²å®Œæˆ',
                'failed': 'å¤±è´¥'
            };
            return texts[status] || status;
        }

        // å…³é—­è¯¦æƒ…é¢æ¿
        function closeDetails() {
            document.getElementById('detailsPanel').classList.add('collapsed');
        }

        // æ·»åŠ æ–° Agent
        function addNewAgent() {
            const roles = Object.keys(agentRoles);
            const newId = Math.max(...agents.map(a => a.id), 0) + 1;
            const newRole = roles[Math.floor(Math.random() * roles.length)];
            const newAgent = {
                id: newId,
                name: `Agent ${newId}`,
                role: newRole,
                status: 'waiting',
                x: 200 + Math.random() * 400,
                y: 100 + Math.random() * 400
            };
            agents.push(newAgent);
            renderAgents();
            renderFlow();
            selectAgent(newId);
        }

        // æ—¶é—´çº¿æ§åˆ¶
        function togglePlay() {
            isPlaying = !isPlaying;
            document.getElementById('playIcon').innerHTML = isPlaying
                ? '<rect x="6" y="4" width="4" height="16"/><rect x="14" y="4" width="4" height="16"/>'
                : '<polygon points="5 3 19 12 5 21 5 3"/>';

            if (isPlaying) {
                animate();
            } else {
                cancelAnimationFrame(animationId);
            }
        }

        function animate() {
            if (!isPlaying) return;
            currentTime += 0.1;
            if (currentTime >= messages.length) {
                currentTime = 0;
            }
            updateTimeline();
            animationId = requestAnimationFrame(animate);
        }

        function updateTimeline() {
            const progress = (currentTime / Math.max(messages.length, 1)) * 100;
            document.getElementById('progressBar').style.width = `${progress}%`;

            const currentM = Math.floor(currentTime);
            const totalM = messages.length;
            document.getElementById('timelineTime').textContent = `${currentM}:${Math.floor((currentTime % 1) * 60).toString().padStart(2, '0')} / ${totalM}:00`;
        }

        function skipToStart() {
            currentTime = 0;
            updateTimeline();
        }

        function skipToEnd() {
            currentTime = Math.max(0, messages.length - 1);
            updateTimeline();
        }

        function stepForward() {
            currentTime = Math.min(currentTime + 1, messages.length - 1);
            updateTimeline();
        }

        function stepBackward() {
            currentTime = Math.max(currentTime - 1, 0);
            updateTimeline();
        }

        function seekTimeline(event) {
            const rect = event.target.getBoundingClientRect();
            const percent = (event.clientX - rect.left) / rect.width;
            currentTime = percent * Math.max(0, messages.length - 1);
            updateTimeline();
        }

        // å¯¼å‡ºåŠŸèƒ½
        function exportPNG() {
            alert('å¯¼å‡º PNG åŠŸèƒ½å¼€å‘ä¸­...');
        }

        function exportJSON() {
            const data = {
                agents: agents,
                messages: messages,
                exportedAt: new Date().toISOString()
            };
            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'agent-workflow.json';
            a.click();
            URL.revokeObjectURL(url);
        }

        // åˆå§‹åŒ–
        initDemo();

        // ======== Three.js 3D åœºæ™¯åŠŸèƒ½ ========

        function init3DScene() {
            const container = document.getElementById('visualization');
            const canvas = document.getElementById('threeCanvas');

            // åœºæ™¯
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0f172a);

            // ç›¸æœº
            camera = new THREE.PerspectiveCamera(60, container.clientWidth / container.clientHeight, 0.1, 1000);
            camera.position.set(0, 300, 500);

            // æ¸²æŸ“å™¨
            renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.setPixelRatio(window.devicePixelRatio);

            // è½¨é“æ§åˆ¶
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.minDistance = 200;
            controls.maxDistance = 1000;

            // ç¯å…‰
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(100, 200, 100);
            scene.add(directionalLight);

            const pointLight = new THREE.PointLight(0x8b5cf6, 0.5, 500);
            pointLight.position.set(0, 100, 0);
            scene.add(pointLight);

            // ç½‘æ ¼åœ°é¢
            const gridHelper = new THREE.GridHelper(800, 20, 0x334155, 0x1e293b);
            scene.add(gridHelper);

            // åŠ¨ç”»æ—¶é’Ÿ
            animationClock = new THREE.Clock();

            // çª—å£å¤§å°è°ƒæ•´
            window.addEventListener('resize', onWindowResize);
        }

        function onWindowResize() {
            const container = document.getElementById('visualization');
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        }

        function createAgentMesh(agent) {
            const role = agentRoles[agent.role] || { color: '#6b7280', icon: 'ğŸ¤–' };
            const color = new THREE.Color(role.color || '#6b7280');

            // Agent ä¸»ä½“ - 3D çƒä½“
            const geometry = new THREE.SphereGeometry(30, 32, 32);
            const material = new THREE.MeshPhongMaterial({
                color: color,
                emissive: color,
                emissiveIntensity: 0.3,
                shininess: 100
            });
            const mesh = new THREE.Mesh(geometry, material);

            // ä½ç½®æ˜ å°„ (2D -> 3D)
            mesh.position.x = (agent.x - 400) * 0.8;
            mesh.position.y = 30;
            mesh.position.z = (agent.y - 300) * 0.8;
            mesh.userData = { agentId: agent.id };

            // å…‰æ™•æ•ˆæœ
            const glowGeometry = new THREE.SphereGeometry(35, 32, 32);
            const glowMaterial = new THREE.MeshBasicMaterial({
                color: color,
                transparent: true,
                opacity: 0.2
            });
            const glow = new THREE.Mesh(glowGeometry, glowMaterial);
            mesh.add(glow);

            // çŠ¶æ€æŒ‡ç¤ºå™¨
            const statusColors = {
                'running': 0x22c55e,
                'waiting': 0xeab308,
                'completed': 0x6b7280,
                'failed': 0xef4444
            };
            const statusColor = statusColors[agent.status] || 0x6b7280;

            const statusGeometry = new THREE.RingGeometry(38, 42, 32);
            const statusMaterial = new THREE.MeshBasicMaterial({
                color: statusColor,
                transparent: true,
                opacity: 0.8,
                side: THREE.DoubleSide
            });
            const statusRing = new THREE.Mesh(statusGeometry, statusMaterial);
            statusRing.rotation.x = Math.PI / 2;
            mesh.add(statusRing);

            // æ·»åŠ åˆ°åœºæ™¯
            scene.add(mesh);
            agentMeshes.push(mesh);

            return mesh;
        }

        function updateAgentMeshes() {
            // æ¸…é™¤æ—§çš„ mesh
            agentMeshes.forEach(mesh => {
                scene.remove(mesh);
            });
            agentMeshes = [];

            // é‡æ–°åˆ›å»º
            agents.forEach(agent => {
                createAgentMesh(agent);
            });
        }

        function createMessageParticle(fromAgent, toAgent) {
            const from = new THREE.Vector3(
                (fromAgent.x - 400) * 0.8,
                30,
                (fromAgent.y - 300) * 0.8
            );
            const to = new THREE.Vector3(
                (toAgent.x - 400) * 0.8,
                30,
                (toAgent.y - 300) * 0.8
            );

            // åˆ›å»ºç²’å­
            const geometry = new THREE.SphereGeometry(5, 16, 16);
            const material = new THREE.MeshBasicMaterial({
                color: 0x8b5cf6,
                transparent: true,
                opacity: 0.8
            });
            const particle = new THREE.Mesh(geometry, material);

            particle.position.copy(from);
            particle.userData = {
                start: from,
                end: to,
                progress: 0,
                speed: 0.01
            };

            scene.add(particle);
            messageParticles.push(particle);

            return particle;
        }

        function updateMessageParticles() {
            // æ¸…é™¤æ—§çš„ç²’å­
            messageParticles.forEach(p => scene.remove(p));
            messageParticles = [];

            // åˆ›å»ºæ–°çš„ç²’å­
            messages.forEach(msg => {
                const fromAgent = agents.find(a => a.id === msg.from);
                const toAgent = agents.find(a => a.id === msg.to);
                if (fromAgent && toAgent) {
                    createMessageParticle(fromAgent, toAgent);
                }
            });
        }

        function animate3D() {
            if (!is3DMode) return;

            requestAnimationFrame(animate3D);
            controls.update();

            // ç²’å­åŠ¨ç”»
            messageParticles.forEach(particle => {
                particle.userData.progress += particle.userData.speed;
                if (particle.userData.progress > 1) {
                    particle.userData.progress = 0;
                }

                const t = particle.userData.progress;
                particle.position.lerpVectors(
                    particle.userData.start,
                    particle.userData.end,
                    t
                );

                // è„‰å†²æ•ˆæœ
                const scale = 1 + Math.sin(t * Math.PI * 4) * 0.3;
                particle.scale.set(scale, scale, scale);
            });

            // æ—‹è½¬æ•ˆæœ
            agentMeshes.forEach(mesh => {
                mesh.rotation.y += 0.01;
            });

            renderer.render(scene, camera);
        }

        function toggle3DView() {
            is3DMode = !is3DMode;
            const svgCanvas = document.getElementById('flowCanvas');
            const threeCanvas = document.getElementById('threeCanvas');
            const viewToggle = document.getElementById('viewToggle');

            if (is3DMode) {
                // åˆ‡æ¢åˆ° 3D
                svgCanvas.style.display = 'none';
                threeCanvas.style.display = 'block';
                viewToggle.innerHTML = `
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <rect x="3" y="3" width="18" height="18" rx="2" ry="2"/>
                        <line x1="3" y1="9" x2="21" y2="9"/>
                        <line x1="9" y1="21" x2="9" y2="9"/>
                    </svg>
                    2D è§†å›¾
                `;

                if (!scene) {
                    init3DScene();
                }
                updateAgentMeshes();
                updateMessageParticles();
                animate3D();

                // æ˜¾ç¤ºæ“ä½œæç¤º
                const hint = document.getElementById('viewHint');
                hint.classList.add('show');
                setTimeout(() => hint.classList.remove('show'), 3000);
            } else {
                // åˆ‡æ¢åˆ° 2D
                svgCanvas.style.display = 'block';
                threeCanvas.style.display = 'none';
                viewToggle.innerHTML = `
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M12 2L2 7l10 5 10-5-10-5z"/>
                        <path d="M2 17l10 5 10-5"/>
                        <path d="M2 12l10 5 10-5"/>
                    </svg>
                    3D è§†å›¾
                `;
            }
        }

        // å¯¼å‡ºæ—¶åŒæ­¥ 3D æ•°æ®
        const originalExportJSON = exportJSON;
        exportJSON = function() {
            const data = {
                agents: agents,
                messages: messages,
                exportedAt: new Date().toISOString(),
                viewMode: is3DMode ? '3D' : '2D'
            };
            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'agent-workflow.json';
            a.click();
            URL.revokeObjectURL(url);
        };

        // ======== API Key Management ========

        // API Keys å­˜å‚¨
        let apiKeys = {
            openai: [],
            anthropic: [],
            google: [],
            ollama: []
        };

        // åŠ è½½å­˜å‚¨çš„ API Keys
        function loadApiKeys() {
            const stored = localStorage.getItem('agentVisualizer_apiKeys');
            if (stored) {
                apiKeys = JSON.parse(stored);
            }
            updateAllKeyStatus();
            renderKeysList();
        }

        // ä¿å­˜ API Keys åˆ° localStorage
        function saveApiKeysToStorage() {
            localStorage.setItem('agentVisualizer_apiKeys', JSON.stringify(apiKeys));
        }

        // æ‰“å¼€ API Keys Modal
        function openApiKeysModal() {
            document.getElementById('apiKeysModal').classList.add('show');
            loadApiKeys();
        }

        // å…³é—­ API Keys Modal
        function closeApiKeysModal() {
            document.getElementById('apiKeysModal').classList.remove('show');
        }

        // æ›´æ–° Key çŠ¶æ€æŒ‡ç¤ºå™¨
        function updateKeyStatus(provider) {
            let input, statusEl;
            if (provider === 'ollama') {
                input = document.getElementById('ollamaUrl');
            } else {
                input = document.getElementById(provider + 'Key');
            }
            statusEl = document.getElementById(provider + 'Status');

            if (input && statusEl) {
                if (input.value && input.value.length > 0) {
                    statusEl.classList.add('active');
                    statusEl.classList.remove('inactive');
                } else {
                    statusEl.classList.remove('active');
                    statusEl.classList.add('inactive');
                }
            }
        }

        // æ›´æ–°æ‰€æœ‰ Key çŠ¶æ€
        function updateAllKeyStatus() {
            ['openai', 'anthropic', 'google', 'ollama'].forEach(updateKeyStatus);
        }

        // æ¸²æŸ“å·²ä¿å­˜çš„ Keys åˆ—è¡¨
        function renderKeysList() {
            ['openai', 'anthropic', 'google'].forEach(provider => {
                const listEl = document.getElementById(provider + 'KeysList');
                if (!listEl) return;

                const keys = apiKeys[provider] || [];
                if (keys.length === 0) {
                    listEl.innerHTML = '';
                    return;
                }

                listEl.innerHTML = keys.map((key, idx) => `
                    <div class="api-key-item">
                        <span class="api-key-name">${key.name || 'Key ' + (idx + 1)}</span>
                        <span class="api-key-preview">${key.key.substring(0, 8)}...${key.key.substring(key.key.length - 4)}</span>
                        <button class="api-key-delete" onclick="deleteApiKey('${provider}', ${idx})" title="åˆ é™¤">ğŸ—‘ï¸</button>
                    </div>
                `).join('');
            });
        }

        // ä¿å­˜ API Key
        function saveApiKey(provider) {
            let keyValue, keyName;

            if (provider === 'ollama') {
                keyValue = document.getElementById('ollamaUrl').value.trim();
                keyName = 'æœ¬åœ°æœåŠ¡';
            } else {
                keyValue = document.getElementById(provider + 'Key').value.trim();
                keyName = provider + ' Key ' + ((apiKeys[provider]?.length || 0) + 1);
            }

            if (!keyValue) {
                alert('è¯·è¾“å…¥ API Key');
                return;
            }

            // æ·»åŠ åˆ°åˆ—è¡¨
            if (!apiKeys[provider]) {
                apiKeys[provider] = [];
            }
            apiKeys[provider].push({
                key: keyValue,
                name: keyName,
                createdAt: new Date().toISOString()
            });

            saveApiKeysToStorage();
            updateKeyStatus(provider);
            renderKeysList();

            // æ¸…ç©ºè¾“å…¥æ¡†
            if (provider !== 'ollama') {
                document.getElementById(provider + 'Key').value = '';
            }

            // æ˜¾ç¤ºä¿å­˜æˆåŠŸ
            showNotification('API Key å·²ä¿å­˜', 'success');
        }

        // åˆ é™¤ API Key
        function deleteApiKey(provider, index) {
            if (confirm('ç¡®å®šè¦åˆ é™¤è¿™ä¸ª API Key å—ï¼Ÿ')) {
                apiKeys[provider].splice(index, 1);
                saveApiKeysToStorage();
                updateKeyStatus(provider);
                renderKeysList();
                showNotification('API Key å·²åˆ é™¤', 'success');
            }
        }

        // æµ‹è¯• API Key
        async function testApiKey(provider) {
            let keyValue;
            if (provider === 'ollama') {
                keyValue = document.getElementById('ollamaUrl').value.trim();
            } else {
                keyValue = document.getElementById(provider + 'Key').value.trim();
            }

            if (!keyValue) {
                alert('è¯·å…ˆè¾“å…¥ API Key è¿›è¡Œæµ‹è¯•');
                return;
            }

            const btn = event.target;
            const originalText = btn.textContent;
            btn.textContent = 'æµ‹è¯•ä¸­...';
            btn.disabled = true;

            try {
                if (provider === 'openai') {
                    const response = await fetch('https://api.openai.com/v1/models', {
                        headers: { 'Authorization': 'Bearer ' + keyValue }
                    });
                    if (response.ok) {
                        showNotification('OpenAI API è¿æ¥æˆåŠŸ!', 'success');
                    } else {
                        throw new Error('API Key æ— æ•ˆ');
                    }
                } else if (provider === 'anthropic') {
                    const response = await fetch('https://api.anthropic.com/v1/messages', {
                        method: 'POST',
                        headers: {
                            'x-api-key': keyValue,
                            'anthropic-version': '2023-06-01',
                            'content-type': 'application/json'
                        },
                        body: JSON.stringify({
                            model: 'claude-3-haiku-20240307',
                            max_tokens: 10,
                            messages: [{ role: 'user', content: 'Hi' }]
                        })
                    });
                    if (response.ok || response.status === 400) {
                        showNotification('Anthropic API è¿æ¥æˆåŠŸ!', 'success');
                    } else {
                        throw new Error('API Key æ— æ•ˆ');
                    }
                } else if (provider === 'google') {
                    const response = await fetch('https://generativelanguage.googleapis.com/v1/models?key=' + keyValue);
                    if (response.ok) {
                        showNotification('Google API è¿æ¥æˆåŠŸ!', 'success');
                    } else {
                        throw new Error('API Key æ— æ•ˆ');
                    }
                } else if (provider === 'ollama') {
                    const response = await fetch(keyValue + '/api/tags');
                    if (response.ok) {
                        const data = await response.json();
                        const models = data.models?.map(m => m.name).join(', ') || 'æ— å¯ç”¨æ¨¡å‹';
                        showNotification('Ollama è¿æ¥æˆåŠŸ! å¯ç”¨æ¨¡å‹: ' + models, 'success');
                    } else {
                        throw new Error('æ— æ³•è¿æ¥åˆ° Ollama');
                    }
                }
            } catch (error) {
                showNotification('æµ‹è¯•å¤±è´¥: ' + error.message, 'error');
            } finally {
                btn.textContent = originalText;
                btn.disabled = false;
            }
        }

        // å¯¼å‡ºå¯†é’¥
        function exportKeys() {
            const data = {
                exportedAt: new Date().toISOString(),
                providers: {}
            };

            ['openai', 'anthropic', 'google', 'ollama'].forEach(provider => {
                data.providers[provider] = apiKeys[provider].map(k => ({
                    name: k.name,
                    key: k.key.substring(0, 4) + '****' + k.key.substring(k.key.length - 4),
                    createdAt: k.createdAt
                }));
            });

            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'api-keys-backup.json';
            a.click();
            URL.revokeObjectURL(url);
            showNotification('å¯†é’¥å¤‡ä»½å·²å¯¼å‡º', 'success');
        }

        // æ˜¾ç¤ºé€šçŸ¥
        function showNotification(message, type) {
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                top: 80px;
                right: 20px;
                padding: 12px 20px;
                background: ${type === 'success' ? 'var(--success)' : 'var(--error)'};
                color: white;
                border-radius: 8px;
                font-size: 14px;
                z-index: 2000;
                animation: slideIn 0.3s ease;
            `;
            notification.textContent = message;
            document.body.appendChild(notification);

            setTimeout(() => {
                notification.remove();
            }, 3000);
        }

        // åˆå§‹åŒ– API Keys
        loadApiKeys();

        // ç‚¹å‡»æ¨¡æ€æ¡†å¤–éƒ¨å…³é—­
        document.getElementById('apiKeysModal').addEventListener('click', function(e) {
            if (e.target === this) {
                closeApiKeysModal();
            }
        });
    </script>
</body>
</html>
